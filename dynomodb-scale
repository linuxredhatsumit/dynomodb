#!/usr/bin/env python3

import argparse
import boto3
import time
import logging
import json
import sys
from botocore.exceptions import ClientError

# JSON Logger Formatter
class JsonLogFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "context": getattr(record, "context", "autoscaling"),
            "message": record.getMessage()
        }
        return json.dumps(log_record)

# Setup logging
logger = logging.getLogger()
handler = logging.StreamHandler()
handler.setFormatter(JsonLogFormatter(datefmt="%Y-%m-%d %H:%M:%S"))
logger.addHandler(handler)
logger.setLevel(logging.INFO)

def get_table_description(dynamodb, table_name):
    try:
        return dynamodb.describe_table(TableName=table_name)['Table']
    except ClientError as e:
        logger.error(json.dumps({"context": "describe_table", "error": str(e)}))
        sys.exit(1)

def wait_for_table_active(dynamodb, table_name):
    while True:
        desc = get_table_description(dynamodb, table_name)
        status = desc['TableStatus']
        if status == 'ACTIVE':
            break
        logger.info("Waiting for table to become ACTIVE...", extra={"context": "wait_for_table_active"})
        time.sleep(5)

def update_billing_mode(dynamodb, table_name, mode, read=None, write=None, gsi_throughput=None):
    try:
        if mode == "provisioned":
            logger.info("Switching table to PROVISIONED mode...", extra={"context": "update_billing_mode"})
            gsi_updates = []
            if gsi_throughput:
                for gsi_name, throughput in gsi_throughput.items():
                    gsi_updates.append({
                        'Update': {
                            'IndexName': gsi_name,
                            'ProvisionedThroughput': {
                                'ReadCapacityUnits': throughput['ReadCapacityUnits'],
                                'WriteCapacityUnits': throughput['WriteCapacityUnits']
                            }
                        }
                    })

            update_kwargs = {
                'TableName': table_name,
                'BillingMode': 'PROVISIONED',
                'ProvisionedThroughput': {
                    'ReadCapacityUnits': read or 5,
                    'WriteCapacityUnits': write or 5
                }
            }

            if gsi_updates:
                update_kwargs['GlobalSecondaryIndexUpdates'] = gsi_updates

            dynamodb.update_table(**update_kwargs)

        else:
            logger.info("Switching table to PAY_PER_REQUEST mode...", extra={"context": "update_billing_mode"})
            dynamodb.update_table(
                TableName=table_name,
                BillingMode='PAY_PER_REQUEST'
            )

    except ClientError as e:
        if e.response['Error']['Code'] == "LimitExceededException" and "Update to PayPerRequest mode are limited to once in 1 day" in str(e):
            logger.warning(json.dumps({
                "context": "update_billing_mode",
                "warning": "DynamoDB billing mode switch limit hit. Retry after 24 hours.",
                "error": str(e)
            }))
        else:
            logger.error(json.dumps({"context": "update_billing_mode", "error": str(e)}))
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--tableName", required=True, type=lambda s: s.strip(), help="DynamoDB table name")
    parser.add_argument("--region", required=True, type=str, help="AWS region")
    parser.add_argument("--readMode", choices=["ondemand", "provisioned"], required=True)
    parser.add_argument("--writeMode", choices=["ondemand", "provisioned"], required=True)
    parser.add_argument("--minRead", type=int)
    parser.add_argument("--maxRead", type=int)
    parser.add_argument("--targetRead", type=int)
    parser.add_argument("--minWrite", type=int)
    parser.add_argument("--maxWrite", type=int)
    parser.add_argument("--targetWrite", type=int)

    args = parser.parse_args()
    dynamodb = boto3.client('dynamodb', region_name=args.region)

    desc = get_table_description(dynamodb, args.tableName)
    current_mode = desc.get('BillingModeSummary', {}).get('BillingMode', 'PROVISIONED')

    gsi_throughput = {}
    for gsi in desc.get("GlobalSecondaryIndexes", []):
        gsi_name = gsi["IndexName"]
        gsi_throughput[gsi_name] = {
            'ReadCapacityUnits': args.targetRead or 5,
            'WriteCapacityUnits': args.targetWrite or 5
        }

    if args.readMode == "provisioned" or args.writeMode == "provisioned":
        if current_mode == "PAY_PER_REQUEST":
            update_billing_mode(
                dynamodb,
                args.tableName,
                "provisioned",
                read=args.targetRead,
                write=args.targetWrite,
                gsi_throughput=gsi_throughput
            )
            wait_for_table_active(dynamodb, args.tableName)
        else:
            logger.info("Table is already in PROVISIONED mode. No switch needed.", extra={"context": "mode_check"})
    else:
        if current_mode == "PROVISIONED":
            update_billing_mode(dynamodb, args.tableName, "ondemand")
            wait_for_table_active(dynamodb, args.tableName)
        else:
            logger.info("Table is already in PAY_PER_REQUEST mode. No switch needed.", extra={"context": "mode_check"})

if __name__ == "__main__":
    main()
