def update_billing_mode(dynamodb, table_name, mode, read=None, write=None, gsi_config=None, max_read_units=None, max_write_units=None):
    try:
        updated = False
        table_desc = dynamodb.describe_table(TableName=table_name)["Table"]
        current_mode = table_desc.get("BillingModeSummary", {}).get("BillingMode", "PROVISIONED")

        if mode.upper() == "PROVISIONED":
            if current_mode == "PAY_PER_REQUEST":
                logger.info("Switching table to PROVISIONED mode...", extra={"context": "update_billing_mode"})
                update_kwargs = {
                    'TableName': table_name,
                    'BillingMode': 'PROVISIONED',
                    'ProvisionedThroughput': {
                        'ReadCapacityUnits': read or 5,
                        'WriteCapacityUnits': write or 5
                    }
                }

                if gsi_config:
                    gsi_updates = []
                    for gsi_name, conf in gsi_config.items():
                        gsi_updates.append({
                            'Update': {
                                'IndexName': gsi_name,
                                'ProvisionedThroughput': {
                                    'ReadCapacityUnits': conf.get("ReadCapacityUnits", 5),
                                    'WriteCapacityUnits': conf.get("WriteCapacityUnits", 5)
                                }
                            }
                        })
                    update_kwargs["GlobalSecondaryIndexUpdates"] = gsi_updates

                dynamodb.update_table(**update_kwargs)
                updated = True
                logger.info("Table and GSIs switched to PROVISIONED.", extra={"context": "update_billing_mode"})
                wait_for_table_active(dynamodb, table_name)
            else:
                logger.info("Table already in PROVISIONED mode. Checking GSI configuration...", extra={"context": "gsi.update"})
                if gsi_config:
                    updated = update_gsi_configuration(dynamodb, table_name, gsi_config) or updated

        else:  # PAY_PER_REQUEST mode
            if current_mode == "PROVISIONED":
                logger.info("Switching table to PAY_PER_REQUEST mode...", extra={"context": "update_billing_mode"})
                update_kwargs = {
                    'TableName': table_name,
                    'BillingMode': 'PAY_PER_REQUEST'
                }
                
                # Only include OnDemandThroughput if both max_read_units and max_write_units are provided and > 0
                if max_read_units is not None and max_write_units is not None and max_read_units > 0 and max_write_units > 0:
                    update_kwargs['OnDemandThroughput'] = {
                        'MaxReadRequestUnits': max_read_units,
                        'MaxWriteRequestUnits': max_write_units
                    }
                    logger.info(json.dumps({
                        "context": "update_billing_mode",
                        "message": f"Setting maximum read request units to {max_read_units} and write request units to {max_write_units}"
                    }))
                    
                dynamodb.update_table(**update_kwargs)
                updated = True
                wait_for_table_active(dynamodb, table_name)
            else:
                # Table is already in PAY_PER_REQUEST mode - check if we need to update max units
                if max_read_units is not None and max_write_units is not None and max_read_units > 0 and max_write_units > 0:
                    logger.info("Table already in PAY_PER_REQUEST mode. Updating maximum request units...", 
                              extra={"context": "update_billing_mode"})
                    update_kwargs = {
                        'TableName': table_name,
                        'OnDemandThroughput': {
                            'MaxReadRequestUnits': max_read_units,
                            'MaxWriteRequestUnits': max_write_units
                        }
                    }
                    dynamodb.update_table(**update_kwargs)
                    updated = True
                    wait_for_table_active(dynamodb, table_name)
                else:
                    logger.info("Table already in PAY_PER_REQUEST mode. No maximum request units specified for update.", 
                              extra={"context": "update_billing_mode"})

        if not updated:
            logger.info("No updates found for table or GSIs.", extra={"context": "update_billing_mode"})
            return

        # Verify final table configuration
        final_desc = dynamodb.describe_table(TableName=table_name)["Table"]
        logger.info(json.dumps({
            "context": "table.verification",
            "message": f"Final table configuration",
            "TableName": table_name,
            "BillingMode": final_desc.get("BillingModeSummary", {}).get("BillingMode", "PROVISIONED"),
            "ReadCapacityUnits": final_desc.get("ProvisionedThroughput", {}).get("ReadCapacityUnits", 0),
            "WriteCapacityUnits": final_desc.get("ProvisionedThroughput", {}).get("WriteCapacityUnits", 0),
            "MaxReadRequestUnits": final_desc.get("OnDemandThroughput", {}).get("MaxReadRequestUnits", "Not set"),
            "MaxWriteRequestUnits": final_desc.get("OnDemandThroughput", {}).get("MaxWriteRequestUnits", "Not set")
        }))

    except ClientError as e:
        logger.error(json.dumps({"context": "update_billing_mode", "error": str(e)}))
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--tableName", required=True)
    parser.add_argument("--region", required=True)
    parser.add_argument("--readMode", choices=["ondemand", "provisioned"], required=True)
    parser.add_argument("--writeMode", choices=["ondemand", "provisioned"], required=True)
    parser.add_argument("--minRead", type=int)
    parser.add_argument("--maxRead", type=int)
    parser.add_argument("--targetRead", type=int)
    parser.add_argument("--minWrite", type=int)
    parser.add_argument("--maxWrite", type=int)
    parser.add_argument("--targetWrite", type=int)
    parser.add_argument("--maxReadUnits", type=int, default=0, help="Maximum read request units for PAY_PER_REQUEST mode (optional)")
    parser.add_argument("--maxWriteUnits", type=int, default=0, help="Maximum write request units for PAY_PER_REQUEST mode (optional)")
    parser.add_argument("--checkGSI", type=lambda x: x.lower() == 'true', default=True)
    parser.add_argument("--dry-run", action="store_true")
    args = parser.parse_args()

    # Log received arguments for debugging
    logger.info(json.dumps({
        "context": "args",
        "message": f"Received arguments: tableName={args.tableName}, region={args.region}, readMode={args.readMode}, writeMode={args.writeMode}, minRead={args.minRead}, maxRead={args.maxRead}, targetRead={args.targetRead}, minWrite={args.minWrite}, maxWrite={args.maxWrite}, targetWrite={args.targetWrite}, maxReadUnits={args.maxReadUnits}, maxWriteUnits={args.maxWriteUnits}, checkGSI={args.checkGSI}, dry-run={args.dry_run}"
    }))

    dynamodb = boto3.client("dynamodb", region_name=args.region)
    autoscaling = boto3.client("application-autoscaling", region_name=args.region)

    logger.info("Found credentials from IAM Role: vpn-access", extra={"context": "autoscaling"})

    desc = get_table_description(dynamodb, args.tableName)
    current_mode = desc.get('BillingModeSummary', {}).get('BillingMode', 'PROVISIONED')
    gsi_config = load_gsi_config(args.tableName, args.checkGSI)
    validate_gsi_config(desc, gsi_config, args.checkGSI)

    if args.dry_run:
        logger.info(json.dumps({
            "context": "dry_run",
            "message": "Dry run mode - no changes applied",
            "tableName": args.tableName,
            "targetBilling": args.readMode,
            "checkGSI": args.checkGSI
        }))
        sys.exit(0)

    # Prepare max units parameters if they're valid
    max_read = args.maxReadUnits if args.maxReadUnits and args.maxReadUnits > 0 else None
    max_write = args.maxWriteUnits if args.maxWriteUnits and args.maxWriteUnits > 0 else None

    if args.readMode == "provisioned" or args.writeMode == "provisioned":
        # Switching to or staying in provisioned mode
        if current_mode == "PAY_PER_REQUEST":
            logger.info("Switching from PAY_PER_REQUEST to PROVISIONED mode", 
                      extra={"context": "mode_change"})
        
        update_billing_mode(dynamodb, args.tableName, "provisioned",
                          read=args.targetRead, write=args.targetWrite,
                          gsi_config=gsi_config)
        wait_for_table_active(dynamodb, args.tableName)

        if args.readMode == "provisioned":
            register_scaling(autoscaling, args.tableName, "dynamodb:table:ReadCapacityUnits",
                           args.minRead or 5, args.maxRead or 100, args.targetRead or 70)

        if args.writeMode == "provisioned":
            register_scaling(autoscaling, args.tableName, "dynamodb:table:WriteCapacityUnits",
                           args.minWrite or 5, args.maxWrite or 100, args.targetWrite or 70)

        if args.checkGSI and gsi_config:
            for index_name, conf in gsi_config.items():
                logger.info(json.dumps({
                    "context": "autoscaling.config",
                    "message": f"Applying autoscaling for index: {index_name}"
                }))

                if "MinReadCapacityUnits" in conf:
                    register_scaling(
                        autoscaling,
                        args.tableName,
                        "dynamodb:index:ReadCapacityUnits",
                        conf["MinReadCapacityUnits"],
                        conf["MaxReadCapacityUnits"],
                        conf["TargetReadUtilization"],
                        index_name=index_name
                    )

                if "MinWriteCapacityUnits" in conf:
                    register_scaling(
                        autoscaling,
                        args.tableName,
                        "dynamodb:index:WriteCapacityUnits",
                        conf["MinWriteCapacityUnits"],
                        conf["MaxWriteCapacityUnits"],
                        conf["TargetWriteUtilization"],
                        index_name=index_name
                    )
    else:
        # Handling on-demand mode cases
        if current_mode == "PROVISIONED":
            # Switching from provisioned to on-demand
            logger.info("Switching from PROVISIONED to PAY_PER_REQUEST mode",
                       extra={"context": "mode_change"})
            deregister_scaling(autoscaling, args.tableName, "dynamodb:table:ReadCapacityUnits")
            deregister_scaling(autoscaling, args.tableName, "dynamodb:table:WriteCapacityUnits")
            
            update_billing_mode(dynamodb, args.tableName, "ondemand",
                              max_read_units=max_read,
                              max_write_units=max_write)
            wait_for_table_active(dynamodb, args.tableName)
        else:
            # Already in on-demand mode - check if we need to update max units
            if max_read is not None and max_write is not None:
                logger.info("Table is already in PAY_PER_REQUEST mode. Updating maximum request units...",
                           extra={"context": "mode_update"})
                update_billing_mode(dynamodb, args.tableName, "ondemand",
                                   max_read_units=max_read,
                                   max_write_units=max_write)
                wait_for_table_active(dynamodb, args.tableName)
            else:
                logger.info("Table already in PAY_PER_REQUEST mode. No maximum request units specified for update.",
                           extra={"context": "mode_check"})

if __name__ == "__main__":
    main()
