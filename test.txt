```yaml
parameters:
  - name: DeployUAT
    type: boolean
    default: true
  - name: service
    type: string
  - name: ImageTag
    type: string
    default: ""

stages:
  - ${{ if eq( parameters['DeployUAT'], true) }}:
      - stage: UAT
        displayName: "Build in UAT Environment"
        jobs:
          - job: UpdateHelmCharts
            displayName: "Cronjob Update"
            steps:
              - script: |
                  pwd
                  if [ -z "${{ parameters.ImageTag }}" ]; then
                    echo "Error: ImageTag parameter is required."
                    exit 1
                  fi
                  echo "Using provided image tag: ${{ parameters.ImageTag }}"
                  echo "##vso[task.setvariable variable=version]${{ parameters.ImageTag }}"
                displayName: "Validate and Set Image Tag"

              - script: |
                  pwd
                  unset AWS_SESSION_TOKEN
                  unset AWS_SECRET_ACCESS_KEY
                  unset AWS_ACCESS_KEY_ID
                  CREDENTIALS=`aws sts assume-role --role-arn arn:aws:iam::$(AWS_ACCOUNT_ID):role/$(ROLE_NAME) --role-session-name $(Build.DefinitionName)-$(Build.BuildNumber)`
                  export AWS_SESSION_TOKEN=`echo $CREDENTIALS | jq -r '.Credentials.SessionToken'`
                  export AWS_SECRET_ACCESS_KEY=`echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey'`
                  export AWS_ACCESS_KEY_ID=`echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId'`
                  echo "Logging into Source (Dev) ECR"
                  aws ecr get-login-password --region $(SOURCE_AWS_REGION) | docker login --username AWS --password-stdin $(AWS_ACCOUNT_ID).dkr.ecr.$(SOURCE_AWS_REGION).amazonaws.com
                  echo "Logging into UAT ECR"
                  aws ecr get-login-password --region $(AWS_REGION) | docker login --username AWS --password-stdin $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com
                  echo "Pulling image from Source (Dev) ECR"
                  docker pull $(AWS_ACCOUNT_ID).dkr.ecr.$(SOURCE_AWS_REGION).amazonaws.com/$(SOURCE_ECR_FOLDER_NAME)/$(SOURCE_ECR_REPO_NAME):${{ parameters.ImageTag }}
                  echo "Tagging image for UAT ECR"
                  docker tag $(AWS_ACCOUNT_ID).dkr.ecr.$(SOURCE_AWS_REGION).amazonaws.com/$(SOURCE_ECR_FOLDER_NAME)/$(SOURCE_ECR_REPO_NAME):${{ parameters.ImageTag }} $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_FOLDER_NAME)/$(ECR_REPO_NAME):${{ parameters.ImageTag }}
                  echo "Pushing image to UAT ECR"
                  docker push $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_FOLDER_NAME)/$(ECR_REPO_NAME):${{ parameters.ImageTag }}
                displayName: "Copy Image from Source (Dev) ECR to UAT ECR"
                condition: and(succeeded(), ne('${{ parameters.ImageTag }}', ''))

              - script: |
                  pwd
                  sed -i -e 's/name:.*/name: ${{ parameters.service }}/' $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/Chart.yaml
                  sed -i -e 's/appVersion:.*/appVersion: 1.$(Build.BuildNumber)/' $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/Chart.yaml
                  sed -i -e 's/version:.*/version: 1.$(Build.BuildNumber)/' $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/Chart.yaml
                  sed -i -e 's|repository:.*|repository: $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_FOLDER_NAME)/$(ECR_REPO_NAME)|' $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/$(ENV)-values.yaml
                  sed -i -e 's/tag:.*/tag: ${{ parameters.ImageTag }}/' $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/$(ENV)-values.yaml
                displayName: "Updating Chart Values"

              - script: |
                  pwd
                  unset AWS_SESSION_TOKEN
                  unset AWS_SECRET_ACCESS_KEY
                  unset AWS_ACCESS_KEY_ID
                  CREDENTIALS=`aws sts assume-role --role-arn arn:aws:iam::$(AWS_ACCOUNT_ID):role/$(ROLE_NAME) --role-session-name $(Build.DefinitionName)-$(Build.BuildNumber)`
                  export AWS_SESSION_TOKEN=`echo $CREDENTIALS | jq -r '.Credentials.SessionToken'`
                  export AWS_SECRET_ACCESS_KEY=`echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey'`
                  export AWS_ACCESS_KEY_ID=`echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId'`
                  helm s3 init $(HELM_S3BUCKET_URL)
                  helm repo add $(ENV)-${{ parameters.service }} $(HELM_S3BUCKET_URL)
                  helm package $(System.DefaultWorkingDirectory)/$(HELM_CHARTS_PATH)/
                  helm s3 push --force $(System.DefaultWorkingDirectory)/${{ parameters.service }}-1.$(Build.BuildNumber).tgz $(ENV)-${{ parameters.service }}
                  aws s3 ls $(HELM_S3BUCKET_URL)
                  helm repo update
                  helm search repo $(ENV)-${{ parameters.service }}
                displayName: "Charts Push To S3"

              - script: |
                  pwd
                  unset AWS_SESSION_TOKEN
                  unset AWS_SECRET_ACCESS_KEY
                  unset AWS_ACCESS_KEY_ID
                  CREDENTIALS=`aws sts assume-role --role-arn arn:aws:iam::$(AWS_ACCOUNT_ID):role/$(ROLE_NAME) --role-session-name $(Build.DefinitionName)-$(Build.BuildNumber)`
                  export AWS_SESSION_TOKEN=`echo $CREDENTIALS | jq -r '.Credentials.SessionToken'`
                  export AWS_SECRET_ACCESS_KEY=`echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey'`
                  export AWS_ACCESS_KEY_ID=`echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId'`
                  rm -rf $(System.DefaultWorkingDirectory)/*.tgz
                  helm repo update
                  helm fetch $(ENV)-${{ parameters.service }}/$(SERVICE_NAME)
                  tar -xvf ${{ parameters.service }}-1.$(Build.BuildNumber).tgz
                  echo "Starting the deployment in the namespace $(NAMESPACE)"
                  helm upgrade --install $(ENV)-${{ parameters.service }} ${{ parameters.service }}/ -f ${{ parameters.service }}/$(ENV)-values.yaml --namespace $(NAMESPACE) --kubeconfig $(KUBE_CONFIG_PATH) --wait --timeout 3m
                displayName: "Helm Charts Deployment"

              - script: |
                  pwd
                  unset AWS_SESSION_TOKEN
                  unset AWS_SECRET_ACCESS_KEY
                  unset AWS_ACCESS_KEY_ID
                  CREDENTIALS=`aws sts assume-role --role-arn arn:aws:iam::$(AWS_ACCOUNT_ID):role/$(ROLE_NAME) --role-session-name $(Build.DefinitionName)-$(Build.BuildNumber)`
                  export AWS_SESSION_TOKEN=`echo $CREDENTIALS | jq -r '.Credentials.SessionToken'`
                  export AWS_SECRET_ACCESS_KEY=`echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey'`
                  export AWS_ACCESS_KEY_ID=`echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId'`
                  echo "########################## List of deployed cronjobs ########################################"
                  kubectl get cronjob --namespace $(NAMESPACE) --kubeconfig $(KUBE_CONFIG_PATH) | grep -i ${{ parameters.service }} || echo "No cronjobs found for ${{ parameters.service }}"
                  echo "########################## List of pods ########################################"
                  kubectl get po --namespace $(NAMESPACE) --kubeconfig $(KUBE_CONFIG_PATH) | grep -i ${{ parameters.service }} || echo "No pods found for ${{ parameters.service }} in namespace $(NAMESPACE)"
                  echo "########################## Get logs of latest pod ########################################"
                  POD_NAME=$(kubectl get pods --sort-by=.metadata.creationTimestamp -l app=${{ parameters.service }} -n $(NAMESPACE) --kubeconfig $(KUBE_CONFIG_PATH) -o jsonpath='{.items[-1:].metadata.name}' 2>/dev/null)
                  if [ -n "$POD_NAME" ]; then
                    kubectl logs $POD_NAME -n $(NAMESPACE) --kubeconfig $(KUBE_CONFIG_PATH) || echo "Failed to retrieve logs for pod $POD_NAME"
                  else
                    echo "No pods found to retrieve logs for ${{ parameters.service }} in namespace $(NAMESPACE)"
                  fi
                displayName: "Application Status"
                continueOnError: true
```
